from typing import Optional, List
from ninja import Router
from ninja.errors import HttpError

from core.auth import BearerAuth
from core.schemas import (
    RoomSchema,
    RoomListResponse,
    RoomSyncResponse,
    RoomSummaryResponse,
    RoomCheckResponse,
    TodoItem,
    ActionItem,
    ConversationSummaryResponse,
    RoomMessagesRequest,
)
from core.services import MatrixService, RoomService

router = Router()


def room_to_schema(room) -> RoomSchema:
    """Convert Room model to RoomSchema."""
    return RoomSchema(
        id=room.id,
        room_id=room.room_id,
        name=room.name,
        creator=room.creator,
        member_count=room.member_count,
        room_created_at=room.room_created_at,
        is_checked=room.is_checked,
        last_checked_at=room.last_checked_at,
        created_at=room.created_at,
        updated_at=room.updated_at,
    )


@router.post("/sync", response=RoomSyncResponse)
def sync_rooms(request):
    """
    Sync rooms from Matrix/Synapse API.

    Fetches all rooms from the Synapse admin API where the creator is
    @friday:matrix.tirta.me, and stores them in the database as unchecked.
    """
    matrix_service = MatrixService()
    room_service = RoomService()

    try:
        matrix_service.login()
        rooms_data = matrix_service.fetch_all_rooms()
        result = room_service.sync_rooms(rooms_data)

        return RoomSyncResponse(
            synced_count=result["synced_count"],
            new_rooms=result["new_rooms"],
            updated_rooms=result["updated_rooms"],
            message=f"Successfully synced {result['synced_count']} rooms",
        )
    except Exception as e:
        raise HttpError(500, f"Sync failed: {str(e)}")


@router.get("/", response=RoomListResponse)
def list_rooms(request, checked: Optional[bool] = None):
    """
    List all rooms.

    Query params:
        checked: Filter by is_checked status (true/false)
    """
    room_service = RoomService()

    if checked is None:
        rooms = room_service.get_all_rooms()
    elif checked:
        from core.models import Room

        rooms = list(Room.objects.filter(is_checked=True).order_by("-created_at"))
    else:
        rooms = room_service.get_unchecked_rooms()

    return RoomListResponse(
        rooms=[room_to_schema(r) for r in rooms],
        total_count=len(rooms),
    )


@router.get("/unchecked", response=RoomSummaryResponse)
def get_unchecked_rooms_summary(request):
    """
    Get all unchecked rooms with AI-powered summary and TODO list.

    Returns rooms that haven't been checked yet along with a summary
    generated by Claude that includes prioritized actions.
    """
    room_service = RoomService()

    rooms = room_service.get_unchecked_rooms()
    summary_data = room_service.generate_summary(rooms)

    todo_items = []
    for item in summary_data.get("todo_list", []):
        todo_items.append(
            TodoItem(
                room_id=item.get("room_id", ""),
                room_name=item.get("room_name"),
                action=item.get("action", "Review room"),
                priority=item.get("priority", "medium"),
            )
        )

    return RoomSummaryResponse(
        rooms=[room_to_schema(r) for r in rooms],
        total_unchecked=len(rooms),
        summary=summary_data.get("summary", ""),
        todo_list=todo_items,
    )


@router.post("/{room_id}/check", response=RoomCheckResponse)
def mark_room_checked(request, room_id: int, notes: Optional[str] = None):
    """
    Mark a room as checked.

    Args:
        room_id: Database ID of the room
        notes: Optional notes about the check
    """
    room_service = RoomService()

    try:
        room = room_service.mark_as_checked(room_id, notes=notes)

        return RoomCheckResponse(
            room=room_to_schema(room),
            message=f"Room {room.room_id} marked as checked",
        )
    except Exception as e:
        raise HttpError(404, f"Room not found: {str(e)}")


@router.post("/summarize/{matrix_room_id}", response=ConversationSummaryResponse)
def summarize_room_conversation(request, matrix_room_id: str):
    """
    Generate an AI summary of a room's conversation.

    Fetches messages from the Matrix API starting from last_checked_at,
    generates a summary using Claude AI, identifies action items,
    and stores the results in the database.

    Args:
        matrix_room_id: The Matrix room ID (e.g., "!abc123:matrix.org")
    """
    matrix_service = MatrixService()
    room_service = RoomService()

    try:
        matrix_service.login()
        result = room_service.summarize_room_conversation(
            matrix_room_id=matrix_room_id, matrix_service=matrix_service
        )

        action_items = []
        for item in result.get("action_items", []):
            action_items.append(
                ActionItem(
                    description=item.get("description", ""),
                    assignee=item.get("assignee"),
                    due_date=item.get("due_date"),
                    priority=item.get("priority", "medium"),
                )
            )

        return ConversationSummaryResponse(
            room=room_to_schema(result["room"]),
            summary=result["summary"],
            action_items=action_items,
            message_count=result["message_count"],
            from_timestamp=result["from_timestamp"],
            to_timestamp=result["to_timestamp"],
            check_log_id=result["check_log_id"],
        )
    except ValueError as e:
        raise HttpError(404, str(e))
    except Exception as e:
        raise HttpError(500, f"Summary generation failed: {str(e)}")


@router.post("/messages", auth=BearerAuth())
def get_room_messages(request, payload: RoomMessagesRequest):
    """
    Get messages from a specific Matrix room.

    Requires Authorization header with Bearer token.

    Body:
        room_id: The Matrix room ID (e.g., "!abc123:matrix.org")
        room_name: The display name of the room
        limit: Maximum number of messages to fetch (default: 100)
    """
    room_service = RoomService()

    result = room_service.get_messages(
        room_id=payload.room_id,
        room_name=payload.room_name,
        access_token=request.auth,
        limit=payload.limit,
    )
    return result
